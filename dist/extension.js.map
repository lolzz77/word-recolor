{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://wordrecolor/external commonjs \"vscode\"","webpack://wordrecolor/external node-commonjs \"fs\"","webpack://wordrecolor/external node-commonjs \"path\"","webpack://wordrecolor/webpack/bootstrap","webpack://wordrecolor/./src/extension.ts"],"sourcesContent":["module.exports = require(\"vscode\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nvar decorationTypeArr:decorationInterface[] = [];\n\ninterface decorationInterface {\n\tdecorationTypeArr:vscode.TextEditorDecorationType;\n\tranges:vscode.Range[];\n}\n\nexport function activate(context: vscode.ExtensionContext) {\n\tlet disposable1 = vscode.commands.registerCommand('wordrecolor.activate', () => {\n\t\tlet editor = vscode.window.activeTextEditor;\n\t\tif(!editor)\n\t\t\treturn;\n\t\n\t\t// just a note, you can set the italic font style and such\n\t\t// const nullDecorationType = vscode.window.createTextEditorDecorationType({\n\t\t//     color: '#ff00f2', // Pink\n\t\t// \tfontStyle: 'italic',\n\t\t// \t// This is how you do it\n\t\t// \t// fontWeight: 'bold',\n\t\t// \t// fontStyle: 'italic',\n\t\t// \t// textDecoration: 'underline'\n\t\t// });\n\t\t\n\t\t// This is to delay the trigger update\n\t\t// This is to increase performance\n\t\t// Now, everytime you type in file, it will trigger the extension to colorize words\n\t\t// However, we dont want it to colorize immediately, but after a short delay\n\t\tlet timeout: NodeJS.Timer | undefined = undefined;\n\t\t\n\t\t// main function, will recolor the words\n\t\tfunction updateDecorations() {\n\n\t\t\tlet language = getCurrentActiveEditorLanguage();\n\t\t\t// for now, just make it to plaintext.json first\n\t\t\tlet JSONPath = getJSONPath(language);\n\t\t\tcreate_JSON_file_if_not_exist(JSONPath, language);\n\t\t\tlet JSONData = getJSONData(JSONPath);\n\n\t\t\tvar editor = vscode.window.activeTextEditor;\n\t\t\tif(!editor)\n\t\t\t\treturn;\n\t\t\tvar document = editor.document;\n\t\t\tvar text = document.getText();\n\t\t\tvar ranges: vscode.Range[] = [];\n\t\t\tlet colors = Object.keys(JSONData);\n\t\t\t// for each color, set decoration\n\t\t\tfor (let color of colors) {\n\t\t\t\tlet keywords = JSONData[color];\n\t\t\t\t// for each keywords of the colors, set up ranges\n\t\t\t\tfor (let keyword of keywords) {\n\t\t\t\t\tlet match;\n\t\t\t\t\t// match case-insensitive-ly\n\t\t\t\t\tlet regex = new RegExp(\"\\\\b(\" + keyword + \")\\\\b\", \"gi\");\n\t\t\t\t\twhile (match = regex.exec(text)) {\n\t\t\t\t\t\tconst start = document.positionAt(match.index);\n\t\t\t\t\t\tconst end = document.positionAt(match.index + match[0].length);\n\t\t\t\t\t\tconst range = new vscode.Range(start, end);\n\t\t\t\t\t\t// put these words into array\n\t\t\t\t\t\tranges.push(range);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdecorationTypeArr.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tdecorationTypeArr : vscode.window.createTextEditorDecorationType({color: color}),\n\t\t\t\t\t\t// this pushes a copy of the array\n\t\t\t\t\t\t// if dont do this, the array pushed into here, are of the same array\n\t\t\t\t\t\t// once the original got modified, this will be modified as well\n\t\t\t\t\t\tranges: [...ranges]\n\t\t\t\t\t});\n\t\t\t}\n\t\t\tfor(const decorationInterface of decorationTypeArr)\n\t\t\t{\n\t\t\t\tlet decorationType = decorationInterface.decorationTypeArr;\n\t\t\t\tlet ranges = decorationInterface.ranges;\n\t\t\t\t// change the color, according to the words in the array\n\t\t\t\teditor.setDecorations(decorationType, ranges);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction triggerUpdateDecorations() {\n\t\t\tif (timeout) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\ttimeout = undefined;\n\t\t\t}\n\t\t\ttimeout = setTimeout(updateDecorations, 500);\n\t\t}\n\t\n\t\t// This one I think apply changes based on current active file you're editting\n\t\tif (vscode.window.activeTextEditor) {\n\t\t\tresetDecoration(decorationTypeArr);\n\t\t\ttriggerUpdateDecorations();\n\t\t}\n\t\t\n\t\t// This one will handle event handling\n\t\t// This will trigger function to colotizes the word\n\t\tvscode.window.onDidChangeActiveTextEditor(editor => {\n\t\t\tif(!editor)\n\t\t\t\treturn;\n\t\t\tresetDecoration(decorationTypeArr);\n\t\t\ttriggerUpdateDecorations();\n\t\t}, null, context.subscriptions);\n\t\t\n\t\t// This one will handle event handling\n\t\t// This will trigger function to colotizes the word\n\t\tvscode.workspace.onDidChangeTextDocument(event => {\n\t\t\tif (vscode.window.activeTextEditor && event.document === vscode.window.activeTextEditor.document) {\n\t\t\t\tresetDecoration(decorationTypeArr);\n\t\t\t\ttriggerUpdateDecorations();\n\t\t\t}\n\t\t}, null, context.subscriptions);\n\t});\n\n\tlet disposable2 = vscode.commands.registerCommand('wordrecolor.showPath', () => {\n\t\tlet JSONPath = getJSONPath(null);\n\t\tvscode.window.showInformationMessage(JSONPath);\n\t});\n\n\tlet disposable3 = vscode.commands.registerCommand('wordrecolor.clear', () => {\n\t\tresetDecoration(decorationTypeArr);\n\t});\n\n\tlet disposable4 = vscode.commands.registerCommand('wordrecolor.restart', () => {\n\t\tdeactivate();\t\t\n\t\tactivate(context);\n\t});\n\t\n\t// This will put the command specified in package.json into command palette (CTRL + SHIFT + P)\n\tcontext.subscriptions.push(disposable1);\n\tcontext.subscriptions.push(disposable2);\n\tcontext.subscriptions.push(disposable3);\n\tcontext.subscriptions.push(disposable4);\n}\n\n// this method is called when your extension is disabled\nexport function deactivate() {\n\tresetDecoration(decorationTypeArr);\n\t// Delete all JSON file\n\t// Probably no need, as user mayu reenable the extension again and finds the JSON they did is gone lmao\n\t// I guess it will be gone once you uninstall the extension\n\t// removeAllJSONFromDirectory();\n}\n\nexport function removeAllJSONFromDirectory(): void {\n    const JSONPath = getJSONPath(null);\n    const dirPath = path.dirname(JSONPath);\n\n    if (!fs.existsSync(dirPath)) {\n\t\treturn;\n\t}\n\n\t// Read all files in the directory\n\tfs.readdir(dirPath, (err, files) => {\n\t\tif (err) {\n\t\t\tconsole.error(`Error reading directory: ${err.message}`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Iterate over all files and delete them\n\t\tfiles.forEach(file => {\n\t\t\tconst fileToDelete = path.join(dirPath, file);\n\t\t\tfs.unlink(fileToDelete, (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.error(`Error deleting file: ${fileToDelete} - ${err.message}`);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n}\n\n// Get the JSON File\nfunction getJSONData(JSONPath: string): any {\n\tlet fileContents = fs.readFileSync(JSONPath, \"utf8\");\n\tlet JSONData: any = JSON.parse(fileContents);\n\treturn JSONData;\n}\n\n// To get the JSON file path that the extension will be looking\n// This JSON describe what keyword to recolor\nfunction getJSONPath(language: string|null): string {\n\t// if language passed in is null, then set it to 'plaintext.json'\n\tif(language == null)\n\t\tlanguage = 'plaintext'\n\treturn vscode.env.appRoot + '/word-recolor/' + language + '.json';\n}\n\n// To get the current active editor language\nfunction getCurrentActiveEditorLanguage(): string {\n\tlet language;\n\tlet editor = vscode.window.activeTextEditor;\n\t\n\tif (editor) {\n\t\tlanguage = editor.document.languageId;\n\t}\n\telse\n\t{\n\t\tlanguage = 'No language detected';\n\t}\n\n\treturn language;\n}\n\n// Generated by Bing\nfunction getFunctionNameAndLineNumber(): [string, number] {\n    const error = new Error();\n    const stack = error.stack?.split('\\n')[2];\n    const functionName = stack?.match(/at (\\S+)/)?.[1] ?? '';\n    const lineNumber = parseInt(stack?.match(/:(\\d+):/)?.[1] ?? '', 10);\n    return [functionName, lineNumber];\n}\n\n// for resetting the decoration applied to active editor\nexport function resetDecoration(decorationTypes:decorationInterface[])\n{\n\t// Reset all decoration types to their default state\n\tfor (const decorationInterface of decorationTypes) {\n\t\tdecorationInterface.decorationTypeArr.dispose();\n\t\t// it seems vscode.Range has no dispose() method\n\t\t// just set the array to null them.\n\t\tdecorationInterface.ranges.length = 0;\n\t}\n\t// delete all the elements\n\tdecorationTypes.length = 0;\n}\n\n\n// to create file, then write the JSON content into it\nexport function create_JSON_file_if_not_exist(filePath:string, language:string|null): void {\n\tlet readBuffer = '';\n\tlet readBufferJSON = '';\n\tlet writeBuffer = '';\n\tlet segments;\n\tlet parentDir:any;\n\n\t// the current repo json file\n\t// eg: word-recolor/jsonFile/plaintext.json\n\t// Note: Im referring this repo JSON file.\n\tlet repo_json_file = __dirname + \"/../jsonFile/\" + language + \".json\";\n\n\t// get the parent dir of the file path\n\tsegments = filePath.split('/'); // split the path by slashes\n\tsegments.pop(); // remove the last segment (file name)\n\tparentDir = segments.join('/'); // join the remaining segments with slashes\n\t\n\t// check if the JSON file that im going to write exists in the user folder\n\t// eg: /root/.vscode-server/bin/138f619c86f1199955d53b4166bef66ef252935c/word-recolor/plaintext.json\n\t// Note: This is not the repo JSON file.\n\tif (fs.existsSync(filePath)) {\n\t\treturn;\n\t}\n\n\t// only read if the repo JSON file exists\n\t// eg: word-recolor/jsonFile/plaintext.json\n\t// Note: Im referring this repo JSON file.\n\tif (fs.existsSync(repo_json_file)) {\n\t\treadBuffer = fs.readFileSync(repo_json_file, 'utf-8');\n\t\treadBufferJSON = JSON.parse(readBuffer);\n\t\twriteBuffer = JSON.stringify(readBufferJSON, null, 4); // 4 spaces indentation\n\t}\n\t// create parent folder if not exists\n\tif (!fs.existsSync(parentDir))\n\t{\n\t\tfs.mkdir(parentDir, { recursive : true }, (err) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconsole.log(parentDir + \" created\");\n\t\t\t}\n\t\t})\n\t}\n\n\t// create file & write\n\tfs.writeFileSync(filePath, writeBuffer, 'utf8');\n}\n"],"names":["module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","decorationTypeArr","deactivate","resetDecoration","getJSONPath","language","vscode","env","appRoot","decorationTypes","decorationInterface","dispose","ranges","length","create_JSON_file_if_not_exist","filePath","segments","parentDir","readBuffer","readBufferJSON","writeBuffer","repo_json_file","__dirname","split","pop","join","fs","existsSync","readFileSync","JSON","parse","stringify","mkdir","recursive","err","console","error","log","writeFileSync","activate","context","disposable1","commands","registerCommand","timeout","updateDecorations","editor","window","activeTextEditor","document","languageId","getCurrentActiveEditorLanguage","JSONPath","JSONData","fileContents","getJSONData","text","getText","colors","Object","keys","color","keywords","keyword","match","regex","RegExp","exec","start","positionAt","index","end","range","Range","push","createTextEditorDecorationType","decorationType","setDecorations","triggerUpdateDecorations","clearTimeout","setTimeout","onDidChangeActiveTextEditor","subscriptions","workspace","onDidChangeTextDocument","event","disposable2","showInformationMessage","disposable3","disposable4","dirPath","path","dirname","readdir","files","message","forEach","file","fileToDelete","unlink"],"sourceRoot":""}