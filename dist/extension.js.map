{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://wordrecolor/external commonjs \"vscode\"","webpack://wordrecolor/external node-commonjs \"fs\"","webpack://wordrecolor/webpack/bootstrap","webpack://wordrecolor/./src/extension.ts"],"sourcesContent":["module.exports = require(\"vscode\");","module.exports = require(\"fs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\nimport * as fs from 'fs';\n\nvar decorationTypeArr:decorationInterface[] = [];\n\ninterface decorationInterface {\n\tdecorationTypeArr:vscode.TextEditorDecorationType;\n\tranges:vscode.Range[];\n}\n\nexport function activate(context: vscode.ExtensionContext) {\n\tlet disposable1 = vscode.commands.registerCommand('wordrecolor.activate', () => {\n\t\tlet editor = vscode.window.activeTextEditor;\n\t\tif(!editor)\n\t\t\treturn;\n\t\tlet language = getCurrentActiveEditorLanguage();\n\t\t// for now, just make it to default.json first\n\t\tlet JSONPath = getJSONPath(null);\n\t\tcreateAndWriteFile(JSONPath, null);\n\t\tlet data = getJSONData(JSONPath);\n\t\n\t\t// just a note, you can set the italic font style and such\n\t\t// const nullDecorationType = vscode.window.createTextEditorDecorationType({\n\t\t//     color: '#ff00f2', // Pink\n\t\t// \tfontStyle: 'italic',\n\t\t// \t// This is how you do it\n\t\t// \t// fontWeight: 'bold',\n\t\t// \t// fontStyle: 'italic',\n\t\t// \t// textDecoration: 'underline'\n\t\t// });\n\t\t\n\t\t// This is to delay the trigger update\n\t\t// This is to increase performance\n\t\t// Now, everytime you type in file, it will trigger the extension to colorize words\n\t\t// However, we dont want it to colorize immediately, but after a short delay\n\t\tlet timeout: NodeJS.Timer | undefined = undefined;\n\t\t\n\t\t// main function, will recolor the words\n\t\tfunction updateDecorations() {\n\t\t\tvar editor = vscode.window.activeTextEditor;\n\t\t\tif(!editor)\n\t\t\t\treturn;\n\t\t\tvar document = editor.document;\n\t\t\tvar text = document.getText();\n\t\t\tvar ranges: vscode.Range[] = [];\n\t\t\tlet colors = Object.keys(data);\n\t\t\t// for each color, set decoration\n\t\t\tfor (let color of colors) {\n\t\t\t\tlet keywords = data[color];\n\t\t\t\t// for each keywords of the colors, set up ranges\n\t\t\t\tfor (let keyword of keywords) {\n\t\t\t\t\tlet match;\n\t\t\t\t\t// match case-insensitive-ly\n\t\t\t\t\tlet regex = new RegExp(\"\\\\b(\" + keyword + \")\\\\b\", \"gi\");\n\t\t\t\t\twhile (match = regex.exec(text)) {\n\t\t\t\t\t\tconst start = document.positionAt(match.index);\n\t\t\t\t\t\tconst end = document.positionAt(match.index + match[0].length);\n\t\t\t\t\t\tconst range = new vscode.Range(start, end);\n\t\t\t\t\t\t// put these words into array\n\t\t\t\t\t\tranges.push(range);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdecorationTypeArr.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tdecorationTypeArr : vscode.window.createTextEditorDecorationType({color: color}),\n\t\t\t\t\t\t// this pushes a copy of the array\n\t\t\t\t\t\t// if dont do this, the array pushed into here, are of the same array\n\t\t\t\t\t\t// once the original got modified, this will be modified as well\n\t\t\t\t\t\tranges: [...ranges]\n\t\t\t\t\t});\n\t\t\t}\n\t\t\tfor(const decorationInterface of decorationTypeArr)\n\t\t\t{\n\t\t\t\tlet decorationType = decorationInterface.decorationTypeArr;\n\t\t\t\tlet ranges = decorationInterface.ranges;\n\t\t\t\t// change the color, according to the words in the array\n\t\t\t\teditor.setDecorations(decorationType, ranges);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction triggerUpdateDecorations() {\n\t\t\tif (timeout) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\ttimeout = undefined;\n\t\t\t}\n\t\t\ttimeout = setTimeout(updateDecorations, 500);\n\t\t}\n\t\n\t\t// This one I think apply changes based on current active file you're editting\n\t\tif (vscode.window.activeTextEditor) {\n\t\t\ttriggerUpdateDecorations();\n\t\t}\n\t\t\n\t\t// This one will handle event handling\n\t\t// This will trigger function to colotizes the word\n\t\tvscode.window.onDidChangeActiveTextEditor(editor => {\n\t\t\tif(!editor)\n\t\t\t\treturn;\n\t\t\ttriggerUpdateDecorations();\n\t\t}, null, context.subscriptions);\n\t\t\n\t\t// This one will handle event handling\n\t\t// This will trigger function to colotizes the word\n\t\tvscode.workspace.onDidChangeTextDocument(event => {\n\t\t\tif (vscode.window.activeTextEditor && event.document === vscode.window.activeTextEditor.document) {\n\t\t\t\ttriggerUpdateDecorations();\n\t\t\t}\n\t\t}, null, context.subscriptions);\n\t});\n\n\tlet disposable2 = vscode.commands.registerCommand('wordrecolor.showPath', () => {\n\t\tlet JSONPath = getJSONPath(null);\n\t\tvscode.window.showInformationMessage(JSONPath);\n\t});\n\n\tlet disposable3 = vscode.commands.registerCommand('wordrecolor.clear', () => {\n\t\tresetDecoration(decorationTypeArr);\n\t});\n\t\n\t// This will put the command specified in package.json into command palette (CTRL + SHIFT + P)\n\tcontext.subscriptions.push(disposable1);\n\tcontext.subscriptions.push(disposable2);\n\tcontext.subscriptions.push(disposable3);\n}\n\n// thsi method is called when your extension is disabled\nexport function deactivate() {\n\tresetDecoration(decorationTypeArr);\n}\n\n\n// Get the JSON File\nfunction getJSONData(JSONPath: string): any {\n\tlet fileContents = fs.readFileSync(JSONPath, \"utf8\");\n\tlet data: any = JSON.parse(fileContents);\n\treturn data;\n}\n\n// To get the JSON file path that the extension will be looking\n// This JSON describe what keyword to recolor\nfunction getJSONPath(language: string|null): string {\n\t// if language passed in is null, then set it to 'default.json'\n\tif(language == null)\n\t\tlanguage = 'default'\n\treturn vscode.env.appRoot + '/word-recolor/' + language + '.json';\n}\n\n// To get the current active editor language\nfunction getCurrentActiveEditorLanguage(): string {\n\tlet language;\n\tlet editor = vscode.window.activeTextEditor;\n\t\n\tif (editor) {\n\t\tlanguage = editor.document.languageId;\n\t}\n\telse\n\t{\n\t\tlanguage = 'No language detected';\n\t}\n\n\treturn language;\n}\n\n// Generated by Bing\nfunction getFunctionNameAndLineNumber(): [string, number] {\n    const error = new Error();\n    const stack = error.stack?.split('\\n')[2];\n    const functionName = stack?.match(/at (\\S+)/)?.[1] ?? '';\n    const lineNumber = parseInt(stack?.match(/:(\\d+):/)?.[1] ?? '', 10);\n    return [functionName, lineNumber];\n}\n\n// for resetting the decoration applied to active editor\nexport function resetDecoration(decorationTypes:decorationInterface[])\n{\n\t// Reset all decoration types to their default state\n\tfor (const decorationInterface of decorationTypes) {\n\t\tdecorationInterface.decorationTypeArr.dispose();\n\t\t// it seems vscode.Range has no dispose() method\n\t\t// just set the array to null them.\n\t\tdecorationInterface.ranges.length = 0;\n\t}\n\t// delete all the elements\n\tdecorationTypes.length = 0;\n}\n\n\n// to create file, then write the JSON content into it\nexport function createAndWriteFile(filePath:string, language:string|null): void {\n\tlet readBuffer = '';\n\tlet readBufferJSON = '';\n\tlet writeBuffer = '';\n\tlet segments;\n\tlet parentDir:any;\n\n\tif(language==null)\n\t\tlanguage='default';\n\n\t// the current repo json file\n\tlet repo_json_file = __dirname + \"/../jsonFile/\" + language + \".json\";\n\n\t// get the parent dir of the file path\n\tsegments = filePath.split('/'); // split the path by slashes\n\tsegments.pop(); // remove the last segment (file name)\n\tparentDir = segments.join('/'); // join the remaining segments with slashes\n\t\n\t// only read if the repo JSON file exists\n\tif (fs.existsSync(repo_json_file)) {\n\t\treadBuffer = fs.readFileSync(repo_json_file, 'utf-8');\n\t\treadBufferJSON = JSON.parse(readBuffer);\n\t\twriteBuffer = JSON.stringify(readBufferJSON, null, 4); // 4 spaces indentation\n\t}\n\n\t// check if the JSON file that im going to write exists\n\tif (fs.existsSync(filePath)) {\n\t\treturn;\n\t}\n\n\t// create parent folder if not exists\n\tif (!fs.existsSync(parentDir))\n\t{\n\t\tfs.mkdir(parentDir, { recursive : true }, (err) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconsole.log(parentDir + \" created\");\n\t\t\t}\n\t\t})\n\t}\n\n\t// create file & write\n\tfs.writeFileSync(filePath, writeBuffer, 'utf8');\n}\n"],"names":["module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","decorationTypeArr","getJSONPath","language","vscode","env","appRoot","resetDecoration","decorationTypes","decorationInterface","dispose","ranges","length","createAndWriteFile","filePath","segments","parentDir","readBuffer","readBufferJSON","writeBuffer","repo_json_file","__dirname","split","pop","join","fs","existsSync","readFileSync","JSON","parse","stringify","mkdir","recursive","err","console","error","log","writeFileSync","context","disposable1","commands","registerCommand","window","activeTextEditor","editor","document","languageId","getCurrentActiveEditorLanguage","JSONPath","timeout","data","fileContents","getJSONData","updateDecorations","text","getText","colors","Object","keys","color","keywords","keyword","match","regex","RegExp","exec","start","positionAt","index","end","range","Range","push","createTextEditorDecorationType","decorationType","setDecorations","triggerUpdateDecorations","clearTimeout","setTimeout","onDidChangeActiveTextEditor","subscriptions","workspace","onDidChangeTextDocument","event","disposable2","showInformationMessage","disposable3"],"sourceRoot":""}