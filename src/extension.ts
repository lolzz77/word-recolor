// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import * as vscode from 'vscode';

// This method is called when your extension is activated
// Your extension is activated the very first time the command is executed
export function activate(context: vscode.ExtensionContext) {
	// This will register command name and trigger a function with it
	// The function is empty, because I dont need it
	// I have to write this, else, the extension wont run
	let disposable = vscode.commands.registerCommand('wordrecolor.activate', () => {
		;
	});

	// This will put the command specified in package.json into command palette (CTRL + SHIFT + P)
	context.subscriptions.push(disposable);

    const nullDecorationType = vscode.window.createTextEditorDecorationType({
        color: '#ff00f2', // Pink
		fontStyle: 'italic',
		// This is how you do it
		// fontWeight: 'bold',
		// fontStyle: 'italic',
		// textDecoration: 'underline'
    });
    const trueDecorationType = vscode.window.createTextEditorDecorationType({
        color: '#23ff0a' // Green
    });
    const falseDecorationType = vscode.window.createTextEditorDecorationType({
        color: 'red'
    });

	// This is to delay the trigger update
	// This is to increase performance
	// Now, everytime you type in file, it will trigger the extension to colorize words
	// However, we dont want it to colorize immediately, but after a short delay
    let timeout: NodeJS.Timer | undefined = undefined;

    function updateDecorations() {
        const editor = vscode.window.activeTextEditor;
        if (editor) {
            const document = editor.document;
            const text = document.getText();
            const nullRanges: vscode.Range[] = [];
            const trueRanges: vscode.Range[] = [];
            const falseRanges: vscode.Range[] = [];
            let match;
            const regex = /\b(NULL|TRUE|FALSE|NONE|NOT IN)\b/gi;
            while (match = regex.exec(text)) {
                const start = document.positionAt(match.index);
                const end = document.positionAt(match.index + match[0].length);
                const range = new vscode.Range(start, end);
                switch (match[1].toUpperCase()) {
                    case 'NULL':
                    case 'NONE':
                        nullRanges.push(range);
                        break;
                    case 'TRUE':
                        trueRanges.push(range);
                        break;
                    case 'FALSE':
                    case 'NOT IN':
                        falseRanges.push(range);
                        break;
                }
            }
            editor.setDecorations(nullDecorationType, nullRanges);
            editor.setDecorations(trueDecorationType, trueRanges);
            editor.setDecorations(falseDecorationType, falseRanges);
        }
    }

    function triggerUpdateDecorations() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = undefined;
        }
        timeout = setTimeout(updateDecorations, 500);
    }

	// This one I think apply changes based on current active file you're editting
    if (vscode.window.activeTextEditor) {
		triggerUpdateDecorations();
    }
	
	// This one will handle event handling
	// This will trigger function to colotizes the word
    vscode.window.onDidChangeActiveTextEditor(editor => {
		if (editor) {
			triggerUpdateDecorations();
        }
    }, null, context.subscriptions);
	
	// This one will handle event handling
	// This will trigger function to colotizes the word
    vscode.workspace.onDidChangeTextDocument(event => {
        if (vscode.window.activeTextEditor && event.document === vscode.window.activeTextEditor.document) {
            triggerUpdateDecorations();
        }
    }, null, context.subscriptions);
}

// Generated by Bing
function getFunctionNameAndLineNumber(): [string, number] {
    const error = new Error();
    const stack = error.stack?.split('\n')[2];
    const functionName = stack?.match(/at (\S+)/)?.[1] ?? '';
    const lineNumber = parseInt(stack?.match(/:(\d+):/)?.[1] ?? '', 10);
    return [functionName, lineNumber];
}

// This method is called when your extension is deactivated
export function deactivate() {}
